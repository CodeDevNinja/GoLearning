### 错误异常
在GO语言的错误处理中,错误是软件包API和应用程序用户界面的一个重要组成部分.
排除异常的情况,如果程序运行失败仅被认为是几个预期的结果之一.对于那些运行失败看作是预期结果的函数,他们会返回一个额外的返回值,通常是最后一个来传递错误消息.如果导致失败的原因只有一个,额外的返回值可以是一个布尔值,通常被命名为ok.比如,当从一个map查询一个结果时,可以通过额外的布尔值判断是否成功:
```
if v, ok := m["key"]; ok {
	return v
}
```
但是导致失败的原因通常不止一种,很多时候用户希望了解更多的错误信息.如果只是用简单的布尔类型的状态值将不能满足这个要求.在C语言中,默认采用一个整数类型的errorno来表达错误,这样就可以根据需要定义多种类型错误类型.在go语言中,syscall.Errno 就是对应c语言中errorno 类型的错误.在syscall包中的接口,如果有返回错误的话,底层也是syscall.Error错误类型.
比如我们通过syscall包的接口来修改文件的模式时,如果遇到错误我们可以通过将err强制断言为syscall.Errorno错误类型来处理:
```
err := syscall.Chmod("",0666)
	if err != nil{
		log.Fatal(err.(syscall.Errno))
	}

```
我们还可以进一步地通过类型查询或者类型断言来获取底层真实的错误类型,这样就可以获取更详细的错误信息.不过一般情况下我们并不惯性错误在地城的表达方式,我们只需要知道它是一个错误就可以了.当返回的错误不是nil时,我们可以调用error接口类型的Error 方法来获得字符串类型的错误信息.

在GO语言中,错误被认为是一种可以预期的结果;而异常则是一种非预期的结果,发生异常可能表示程序中存在BUG或发生了其它不可控的问题,Go语言推荐私用recvoer函数将内部异常转为错误处理,这使得用户介意真正的关系业务相关的错误处理.

如果某个接口简单地将所有普通的错误当做异常抛出, 将会使错误信息杂乱且没有价值. 就像在main函数中直接补货全部一样,是没有意义的:
```
func main() {
	defer func() {
		if r := recover(); r != nil {
			log.Fatal(r)
		}
	}()

	...
}
```
捕获异常不是最终的目的.如果异常不可预测,直接输出异常信息是最好的处理方式.

#### 错误处理策略
让我们演示一个文件复制的例子:函数需要打开两个文件,然后将其中一个文件的内容复制到另一个文件:
```
func CopyFile(destName,srcName string)(written int64, err error) {
	src, err := os.Open(srcName)
	if err != nil {
		return
	}
	dst,err := os.Create(destName)
	if err != nil{
		return
	}
	defer src.Close()

	return io.Copy(dst, src)
}

```
defer 语句可以让我们在打开文件时马上思考如何关闭文件,不管函数如何返回,文件关闭四纵会被执行.同时defer语句可以保证,即使io.Copy 发生了异常,文件依然可以安全关闭.
前文我们说到,Go语言中的导出函数一般不抛出异常,一个未受控的异常可以看作是程序的BUG.